var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Y. Pawitan. In All Likelihood: Statistical Modelling and Inference Using Likelihood (Oxford University Press, 2001).\n\n\n\nM. Friendly, G. Monette and J. Fox. Elliptical Insights: Understanding Statistical Methods through Elliptical Geometry. Statistical Science 28, 1–39 (2013). Publisher: Institute of Mathematical Statistics.\n\n\n\n","category":"page"},{"location":"internal_library/","page":"Internal Library","title":"Internal Library","text":"Pages = [\"internal_libary.md\"]","category":"page"},{"location":"internal_library/#Internal-Library","page":"Internal Library","title":"Internal Library","text":"","category":"section"},{"location":"internal_library/","page":"Internal Library","title":"Internal Library","text":"Documentation for structs and functions not covered within User Interface documentation.","category":"page"},{"location":"internal_library/#Structs","page":"Internal Library","title":"Structs","text":"","category":"section"},{"location":"internal_library/","page":"Internal Library","title":"Internal Library","text":"EllipseSampling.Ellipse","category":"page"},{"location":"internal_library/#EllipseSampling.Ellipse","page":"Internal Library","title":"EllipseSampling.Ellipse","text":"Ellipse\n\nContains the information required to define an ellipse which may have been rotated and translated. See construct_ellipse.\n\nFields\n\nx_radius: radius of the ellipse in the x axis (i.e. when the rotation, α, is zero).\ny_radius: radius of the ellipse in the y axis (i.e. when the rotation, α, is zero).\nα: an angle in radians (0 to 2π) that the ellipse has been rotated by. A positive value represents an anti-clockwise rotation.\nCx: the x coordinate of the centre of the ellipse (the translation of the ellipse in the x axis).\nCy: the y coordinate of the centre of the ellipse (the translation of the ellipse in the y axis). \na: the major radius of the ellipse.\nb: the minor radius of the ellipse.\nm: the eccentricity of the ellipse squared. See EllipseSampling.eccentricity_squared.\nem: complete elliptic integral of the second kind evaluated for the eccentricity squared of the ellipse: Elliptic.E(m). See: Elliptic.jl.\ncircumference: the circumference of the ellipse.\n\n\n\n\n\n","category":"type"},{"location":"internal_library/#Functions","page":"Internal Library","title":"Functions","text":"","category":"section"},{"location":"internal_library/","page":"Internal Library","title":"Internal Library","text":"EllipseSampling.eccentricity_squared\nEllipseSampling.circumference\nEllipseSampling.assert_parameters_are_valid\nEllipseSampling.E_inverse\nEllipseSampling.ellipse_zero\nEllipseSampling.calculate_ellipse_parameters","category":"page"},{"location":"internal_library/#EllipseSampling.eccentricity_squared","page":"Internal Library","title":"EllipseSampling.eccentricity_squared","text":"eccentricity_squared(a::T, b::T) where T<:Float64\n\nComputes m, the eccentricity of the ellipse squared, m=e^2, where m=1-big(fracbabig)^2.\n\nArguments\n\na: the major radius of the ellipse.\nb: the minor radius of the ellipse.\n\nDetails\n\nThis relationship between m and e is seen by considering the equation for e: e=fracca, where c^2=big(a^2-b^2big) and ab.\n\nReplacing c in the equation for e: \n\ne=fracsqrta^2-b^2a\n\nSubstituting the equation for e into m: \n\nm = bigg(fracsqrta^2-b^2abigg)^2 = fraca^2-b^2a^2 = 1 - fracb^2a^2 = 1 - bigg(fracbabigg)^2\n\n\n\n\n\n","category":"function"},{"location":"internal_library/#EllipseSampling.circumference","page":"Internal Library","title":"EllipseSampling.circumference","text":"circumference(a::Float64, b::Float64)\n\nCalculates the circumference of an ellipse using the elliptic integral of the second kind. Uses Elliptic.jl.\n\nArguments\n\na: the major radius of the ellipse.\nb: the minor radius of the ellipse.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/#EllipseSampling.assert_parameters_are_valid","page":"Internal Library","title":"EllipseSampling.assert_parameters_are_valid","text":"assert_parameters_are_valid(a::T, b::T, x_radius::T, y_radius::T) where T<:Float64\n\nAsserts that the parameters relate to a valid ellipse. I.e. that a ≥ b and, x_radius and y_radius are positive. Note: a=max(x_radius, y_radius), b=min(x_radius, y_radius).\n\nArguments\n\na: the major radius of the ellipse.\nb: the minor radius of the ellipse.\nx_radius: radius of the ellipse in the x axis (i.e. when the rotation, α, is zero).\ny_radius: radius of the ellipse in the y axis (i.e. when the rotation, α, is zero).\n\n\n\n\n\n","category":"function"},{"location":"internal_library/#EllipseSampling.E_inverse","page":"Internal Library","title":"EllipseSampling.E_inverse","text":"E_inverse(em::T, z::T, m::T) where T<:Float64\n\nJulia version of the python function t_from_length by John D. Cook.\n\nArguments\n\nem: complete elliptic integral of the second kind evaluated for the eccentricity squared of the ellipse: Elliptic.E(m). See: Elliptic.jl.\nz: Difference between em and the quotient of arc length and the major axis radius, em - arc_len/a.\nm: the eccentricity of the ellipse squared. See EllipseSampling.eccentricity_squared.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/#EllipseSampling.ellipse_zero","page":"Internal Library","title":"EllipseSampling.ellipse_zero","text":"ellipse_zero(t::Float64, p::AbstractVector)\n\nUsed by EllipseSampling.E_inverse to find the location t where the function is zero. Equivalent to the anonymous function f(y) = Elliptic.E(y, m) - z.\n\nArguments\n\nx: the argument optimised over.\np: a 2 element static array containing the values for z and m.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/#EllipseSampling.calculate_ellipse_parameters","page":"Internal Library","title":"EllipseSampling.calculate_ellipse_parameters","text":"calculate_ellipse_parameters(Γ::Matrix{Float64}, ind1::Int, ind2::Int,\n    confidence_level::Float64, dof::Int)\n\nGiven a square matrix Γ, the inverse of the Hessian of a log-likelihood function at its maximum likelihood estimate, indexes of the two variables of interest, the confidence level and degrees of freedom used to define ell_c, which constructs a 2D ellipse approximation of the log-likelihood function, return the parameters of that ellipse.\n\nArguments\n\nΓ: a square matrix which is the inverse of the Hessian of a log-likelihood function at its maximum likelihood estimate.\nind1: index of the first parameter of interest (corresponds to the row and column index of Γ)\nind2: index of the second parameter of interest (corresponds to the row and column index of Γ).\nconfidence_level: the confidence level ∈ [0.0,1.0] at which the ellipse approximation is constructed.\ndof: integer degrees of freedom used for calculation of the asymptotic confidence threshold defining the ellipse. Default is 2.\n\nDetails\n\nThe parameters of interest are a and b, the radius of the major and minor axis respectively, x_radius and y_radius, the radius of the ellipse in the x and y axis respectively (i.e. the radius when the rotation α is zero) and α, an angle between 0 and π radians that the major axis of the ellipse has been rotated by from the positive x axis. a is equal to the maximum of x_radius and y_radius, while b is equal to the minimum of x_radius and y_radius.\n\nObserved Fisher Information Matrix and Approximation of the Log-Likelihood Function\n\nWe can approximate a log-likelihood function from multiple parameters, theta, by considering the observed Fisher information matrix (FIM). The observed FIM is a quadratic approximation of the curvature of the log-likelihood function at the maximum likelihood estimate, hattheta. The observed FIM is the matrix of second derivatives (the Hessian) of the log-likelihood function evaluated at the MLE with elements [1]: \n\nH_jk(hattheta) equiv -fracpartial^2partial theta_j partial theta_k ell (hattheta    y_1I^textrmo )\n\nThis then allows us to define the following approximation of the normalised log-likelihood function using a second-order Taylor expansion at the MLE [1]:\n\n    hatell (theta    y_1I^textrmo ) approx -frac12 (theta-hattheta) H(hattheta) (theta-hattheta)\n\nSimilarly, for two parameters, psi, from a larger number of parameters, we first invert the observed FIM, Gamma(hattheta) = H^-1(hattheta), and then select just the rows and columns relating to the parameters of interest, before again inverting the matrix:\n\n    hatell_p (psi    y_1I^textrmo )  approx -frac12 (psi-hatpsi) (e_j e_k  Gamma(hattheta)  e_j e_k)^-1 (psi-hatpsi) hspace02cm theta_j cup theta_k = psi \n\nwhere e_j and e_k are the jth and kth canonical vectors of mathbbR^theta.\n\nObtaining Ellipse parameters\n\nBy normalising our log-likelihood approximation equation for two parameters by our target confidence threshold of interest ell_c (at confidence_level, with dof degrees of freedom, typically 2) so that one side of the equation is equal to 1 we obtain the equation of an ellipse [2]:\n\n1 = -frac12ell_c (psi-hatpsi) (e_j e_k  Gamma(hattheta)  e_j e_k)^-1 (psi-hatpsi) = (psi-hatpsi) mathcalC (psi-hatpsi)\n\nThe major and minor axis radii, a and b respectively, can then be evaluated by considering the inverse of the square roots of the eigenvalues of mathcalC (ordered from largest to smallest) [2]. To determine the rotation, α of the major axis of the ellipse from the positive x axis we calculate the inverse tangent of the division of the y and x components of the eigenvector corresponding to the largest eigenvalue [2]. \n\n\n\n\n\n","category":"function"},{"location":"user_interface/","page":"User Interface","title":"User Interface","text":"Pages = [\"user_interface.md\"]","category":"page"},{"location":"user_interface/#User-Interface","page":"User Interface","title":"User Interface","text":"","category":"section"},{"location":"user_interface/#Ellipse-Construction","page":"User Interface","title":"Ellipse Construction","text":"","category":"section"},{"location":"user_interface/","page":"User Interface","title":"User Interface","text":"For ease of use, all ellipse sampling [generation] functions can either be called directly with ellipse parameters such as a, b and α, or we can construct an EllipseSampling.Ellipse struct first with those parameters, and use this struct when calling the generation functions.","category":"page"},{"location":"user_interface/","page":"User Interface","title":"User Interface","text":"We construct an EllipseSampling.Ellipse struct using construct_ellipse.","category":"page"},{"location":"user_interface/","page":"User Interface","title":"User Interface","text":"construct_ellipse","category":"page"},{"location":"user_interface/#EllipseSampling.construct_ellipse","page":"User Interface","title":"EllipseSampling.construct_ellipse","text":"construct_ellipse(x_radius::T, y_radius::T, α::T=0.0, Cx::T=0.0, Cy::T=0.0) where T<:Float64\n\nConstructs a EllipseSampling.Ellipse struct which contains the information required to define an ellipse which may have been rotated and translated.\n\nArguments\n\nx_radius: radius of the ellipse in the x axis (i.e. when the rotation, α, is zero).\ny_radius: radius of the ellipse in the y axis (i.e. when the rotation, α, is zero).\nα: an angle in radians (0 to 2π) that the ellipse has been rotated by. A positive value represents an anti-clockwise rotation. Default is 0.0.\nCx: the x coordinate of the centre of the ellipse (the translation of the ellipse in the x axis). Default is 0.0.\nCy: the y coordinate of the centre of the ellipse (the translation of the ellipse in the y axis). Default is 0.0.\n\nDetails\n\nThe general equation for a rotated and translated ellipse is given by:\n\n1 = A(x-C_x)^2 + B(x-C_x)(y-C_y) + C(y-C_y)^2\n\nWhere:\n\nA = bigg(fraccos^2(α)a^2 + fracsin^2(α)b^2bigg)\n\nB = 2cos(α)sin(α)bigg(frac1a^2 - frac1b^2bigg)\n\nC = bigg(fracsin^2(α)a^2 + fraccos^2(α)b^2bigg)\n\n\n\n\n\n","category":"function"},{"location":"user_interface/#Sampling-Methods","page":"User Interface","title":"Sampling Methods","text":"","category":"section"},{"location":"user_interface/","page":"User Interface","title":"User Interface","text":"Three sampling methods, generate_N_equally_spaced_points, generate_N_clustered_points and generate_perimeter_point, are provided for use.","category":"page"},{"location":"user_interface/","page":"User Interface","title":"User Interface","text":"generate_N_equally_spaced_points will generate points uniformly with respect to arc length along the perimeter of an ellipse. \ngenerate_N_clustered_points will generate points uniformly with respect to arc length along the perimeter of a distorted version of the input ellipse and then map these onto the input ellipse. The distorted version of the input ellipse varies the major axis radius of the input ellipse between being equal to the minor axis radius and the original major axis radius, allowing a stronger clustering of points around the vertexes of the ellipse on the major axis (i.e. the region of greatest curvature). This means it is a generalised version of generate_N_equally_spaced_points. \ngenerate_perimeter_point will generate a singular point on the ellipse's perimeter given a specified distance along the normalised perimeter ∈ [0,1]. This is useful for defining a custom sampling method not covered by the previous two sampling methods. ","category":"page"},{"location":"user_interface/","page":"User Interface","title":"User Interface","text":"Example use of these functions and visualisation of their outputs is shown in Quick Start","category":"page"},{"location":"user_interface/","page":"User Interface","title":"User Interface","text":"generate_N_equally_spaced_points\ngenerate_N_clustered_points\ngenerate_perimeter_point","category":"page"},{"location":"user_interface/#EllipseSampling.generate_N_equally_spaced_points","page":"User Interface","title":"EllipseSampling.generate_N_equally_spaced_points","text":"generate_N_equally_spaced_points(num_points::Int, e::Ellipse; start_point_shift::Float64=rand())\n\nGenerates num_points equally spaced points on an ellipse defined by the parameters contained within e. The points are returned as an array with two rows and num_points columns, with each point stored in a column.\n\nArguments\n\nnum_points: a positive integer number of points to generate that are equally spaced on the ellipse. \ne: a valid EllipseSampling.Ellipse struct which defines an ellipse.\n\nKeyword Arguments\n\nstart_point_shift: a number ∈ [0.0,1.0]. Default is rand() (defined on [0.0,1.0]), meaning that, by default, every time this function is called a different set of points will be generated.\n\nDetails\n\nPoints are sampled anti-clockwise around the ellipse starting from the most positive vertex on the major axis prior to any rotation. After a rotation is applied, this vertex may no longer be the most positive vertex on the major axis. Vertex here means the two endpoints that lie on the major axis and intersect the ellipse. If start_point_shift=0.0 then the first point on the equally spaced points will be placed on the most positive vertex on the major axis prior to any rotation.\n\nEqual spacing of points on the ellipse is with respect to arc length. The position of the first point placed on the ellipse can be shifted by start_point_shift, defined on [0.0,1.0], allowing the set of possible points generated for a given num_points to cover the full perimeter. This shift is normalised so that when start_point_shift=1.0, the position of the first point placed on the ellipse is equal to the position of the second point placed on the ellipse when start_point_shift=0.0.\n\n\n\n\n\ngenerate_N_equally_spaced_points(num_points::Int, x_radius::T, y_radius::T, α::T=0.0, Cx::T=0.0, Cy::T=0.0; start_point_shift::Float64=rand()) where T<:Float64\n\nAn alternate way to call generate_N_equally_spaced_points(num_points::Int, e::Ellipse; start_point_shift::Float64=rand()), by supplying the parameters of the ellipse to generate points on.\n\nArguments\n\nnum_points: a positive integer number of points to generate that are equally spaced on the ellipse. \nx_radius: radius of the ellipse in the x axis (i.e. when the rotation, α, is zero).\ny_radius: radius of the ellipse in the y axis (i.e. when the rotation, α, is zero).\nα: an angle in radians (0 to 2π) that the ellipse has been rotated by. A positive value represents an anti-clockwise rotation. Default is 0.0.\nCx: the x coordinate of the centre of the ellipse (the translation of the ellipse in the x axis). Default is 0.0.\nCy: the y coordinate of the centre of the ellipse (the translation of the ellipse in the y axis). Default is 0.0.\n\nKeyword Arguments\n\nstart_point_shift: a number ∈ [0.0,1.0]. Default is rand() (defined on [0.0,1.0]), meaning that, by default, every time this function is called a different set of points will be generated.\n\n\n\n\n\ngenerate_N_equally_spaced_points(num_points::Int, Γ::Matrix{Float64}, θmle::Vector{Float64}, ind1::Int, ind2::Int; confidence_level::Float64=0.01, start_point_shift::Float64=rand())\n\nAn alternate way to call generate_N_equally_spaced_points(num_points::Int, e::Ellipse; start_point_shift::Float64=rand()), by supplying a square matrix Γ, the inverse of the Hessian of a log-likelihood function at its maximum likelihood estimate, indexes of the two variables of interest and the confidence level that represent a 2D ellipse approximation of the log-likelihood function.\n\nArguments\n\nnum_points: a positive integer number of points to generate that are equally spaced on the ellipse. \nΓ: a square matrix (2D) which is the inverse of the Hessian of a log-likelihood function at its maximum likelihood estimate.\nθmle: the maximum likelihood estimate for the parameters.\nind1: index of the first parameter of interest (corresponds to the row and column index of Γ)\nind2: index of the second parameter of interest (corresponds to the row and column index of Γ).\n\nKeyword Arguments\n\nconfidence_level: the confidence level ∈ [0.0,1.0] at which the ellipse approximation is constructed. Default is 0.01.\nstart_point_shift: a number ∈ [0.0,1.0]. Default is rand() (defined on [0.0,1.0]), meaning that, by default, every time this function is called a different set of points will be generated.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/#EllipseSampling.generate_N_clustered_points","page":"User Interface","title":"EllipseSampling.generate_N_clustered_points","text":"generate_N_clustered_points(num_points::Int, e::Ellipse; start_point_shift::Float64=rand(), sqrt_distortion::Float64=0.0)\n\nGenerates num_points spaced points on an ellipse defined by the parameters contained within e. The points are returned as an array with two rows and num_points columns, with each point stored in a column.\n\nArguments\n\nnum_points: a positive integer number of points to generate that are spaced on the ellipse. \ne: a valid EllipseSampling.Ellipse struct which defines an ellipse.\n\nKeyword Arguments\n\nstart_point_shift: a number ∈ [0.0,1.0]. Default is rand() (defined on [0.0,1.0]), meaning that, by default, every time this function is called a different set of points will be generated.\nsqrt_distortion: a number ∈ [0.0,1.0]. Default is 0.0, meaning that, by default, this function will evenly space points on the the ellipse e with respect to the parameter t.\n\nDetails\n\nPoints are sampled in the same fashion as in generate_N_equally_spaced_points(num_points::Int, e::Ellipse; start_point_shift::Float64=rand()), except that the spacing of them is dependent on the parameter sqrt_distortion. If sqrt_distortion == 1.0 then these points are equally spaced with respect to the arc length. If sqrt_distortion == 0.0 then these points are equally spaced with respect to the parameter t in the parameteric equations for the x and y locations on an ellipse (x_parametric_equation(t::T, e::Ellipse) where T<:Float64 and y_parametric_equation(t::T, e::Ellipse) where T<:Float64). Varying this parameter between 0.0 and 1.0 allows all of the spacings between these two extremes to be obtained.\n\nThe impact of using this function is that for all values of sqrt_distortion < 1.0, points generated will be more clustered around the vertexes of the ellipse on the major axis (i.e. the region of greatest curvature). The strength of this clustering increases as sqrt_distortion to 00. The strength of the clustering is also dependent on the relative magnitudes of the major and minor axis radii. If the major and minor axis have the same radii, then the ellipse is a circle and no clustering will be observed, irrespective of the value of sqrt_distortion. As the magnitude of the major axis radius increases relative to the minor axis radius, the strength of the clustering will increase. \n\nThis effect is valuable when using an ellipse as a starting point to find a new level set in 2D (that may be an ellipse) that contains the starting ellipse. If we seek to find the new level set by pushing out from the starting ellipse tangentially at each of the generated points then the points that diverge the fastest are located at the region of greatest curvature. If generated points are equally spaced with respect to arc length, then the new level set is likely to be well defined in regions that are approximately parallel to the major axis of the starting ellipse (and with length on a parallel line of similar length to the major axis, particularly for starting ellipses with a significantly larger major axis), but poorly defined in all other regions. The clustering effect is then valuable as it helps to better define the new level set.   \n\nThe function works by defining a new ellipse, e_new with minor axis radius equal to the supplied ellipse's minor axis radius (e_new.b == e.b) and major axis radius as a function of the supplied ellipse's, e, major and minor axis radii and the parameter sqrt_distortion. Namely, e_new.a == e.b + sqrt_distortion^2 * (e.a - e.b). e_new is contained within e and can be varied between a circle and e using the parameter sqrt_distortion ∈ [0.0,1.0]. After defining e_new we determine the angle parameters t_vector that equally spaces num_points on e_new with respect to arc length and then find the points on e parameterised by the elements of t_vector.\n\n\n\n\n\ngenerate_N_clustered_points(num_points::Int, x_radius::T, y_radius::T, α::T=0.0, Cx::T=0.0, Cy::T=0.0; start_point_shift::Float64=rand(), sqrt_distortion::Float64=0.0) where T<:Float64\n\nAn alternate way to call generate_N_clustered_points(num_points::Int, e::Ellipse; start_point_shift::Float64=rand(), sqrt_distortion::Float64=0.), by supplying the parameters of the ellipse to generate points on.\n\nArguments\n\nnum_points: a positive integer number of points to generate that are equally spaced on the ellipse. \nx_radius: radius of the ellipse in the x axis (i.e. when the rotation, α, is zero).\ny_radius: radius of the ellipse in the y axis (i.e. when the rotation, α, is zero).\nα: an angle in radians (0 to 2π) that the ellipse has been rotated by. A positive value represents an anti-clockwise rotation. Default is 0.0.\nCx: the x coordinate of the centre of the ellipse (the translation of the ellipse in the x axis). Default is 0.0.\nCy: the y coordinate of the centre of the ellipse (the translation of the ellipse in the y axis). Default is 0.0.\n\nKeyword Arguments\n\nstart_point_shift: a number ∈ [0.0,1.0]. Default is rand() (defined on [0.0,1.0]), meaning that, by default, every time this function is called a different set of points will be generated.\nsqrt_distortion: a number ∈ [0.0,1.0]. Default is 0.0, meaning that, by default, this function will evenly space points on the the ellipse e with respect to the parameter t.\n\n\n\n\n\ngenerate_N_clustered_points(num_points::Int, Γ::Matrix{Float64}, θmle::Vector{Float64}, ind1::Int, ind2::Int; \n    confidence_level::Float64=0.01, dof::Int=2, start_point_shift::Float64=rand(), sqrt_distortion::Float64=0.0)\n\nAn alternate way to call generate_N_clustered_points(num_points::Int, e::Ellipse; start_point_shift::Float64=rand(), sqrt_distortion::Float64=0.), by supplying a square matrix Γ, the inverse of the Hessian of a log-likelihood function at its maximum likelihood estimate, indexes of the two variables of interest and the confidence level that represent a 2D ellipse approximation of the log-likelihood function.\n\nArguments\n\nnum_points: a positive integer number of points to generate that are equally spaced on the ellipse. \nΓ: a square matrix (2D) which is the inverse of the Hessian of a log-likelihood function at its maximum likelihood estimate.\nθmle: the maximum likelihood estimate for the parameters.\nind1: index of the first parameter of interest (corresponds to the row and column index of Γ)\nind2: index of the second parameter of interest (corresponds to the row and column index of Γ).\n\nKeyword Arguments\n\nconfidence_level: the confidence level ∈ [0.0,1.0] at which the ellipse approximation is constructed. Default is 0.01.\ndof: integer degrees of freedom used for calculation of the asymptotic confidence threshold defining the ellipse. Default is 2.\nstart_point_shift: a number ∈ [0.0,1.0]. Default is rand() (defined on [0.0,1.0]), meaning that, by default, every time this function is called a different set of points will be generated.\nsqrt_distortion: a number ∈ [0.0,1.0]. Default is 0.0, meaning that, by default, this function will evenly space points on the the ellipse e with respect to the parameter t.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/#EllipseSampling.generate_perimeter_point","page":"User Interface","title":"EllipseSampling.generate_perimeter_point","text":"generate_perimeter_point(norm_distance_on_perimeter::Float64, e::Ellipse)\n\nGenerates a single point on an ellipse defined by the parameters contained within e, at distance norm_distance_on_perimeter times e.circumference around the circumference. The point is returned as a vector of length two.\n\nArguments\n\nnorm_distance_on_perimeter: a number ∈ [0.0,1.0] which represents the normalised distance on the perimeter of an ellipse. A value of 0.5 corresponds to a point halfway along the ellipse's perimeter, while a value of 0.7 corresponds to a point 70% along the ellipse's perimeter.\ne: a valid EllipseSampling.Ellipse struct which defines an ellipse.\n\nDetails\n\nPoints are sampled anti-clockwise around the ellipse starting from the most positive vertex on the major axis prior to any rotation. After a rotation is applied, this vertex may no longer be the most positive vertex on the major axis. Vertex here means the two endpoints that lie on the major axis and intersect the ellipse. \n\nConsider a ellipse that has no translation or rotational component. If the x radius is 2.0 and the y radius is 1.0, then the x axis is the major axis. Resultantly, a value of norm_distance_on_perimeter=0.0 will correspond to point [x,y] = [2.0, 0.0]. A value of norm_distance_on_perimeter=0.25, which corresponds to a fracπ2 anti-clockwise rotation around the ellipse will correspond to point [x,y] = [0.0, 1.0]. \n\nusing EllipseSampling\ne = construct_ellipse(2.0, 1.0)\ngenerate_perimeter_point(0.0, e)\ngenerate_perimeter_point(0.25, e)\n\nSimilarly, if the x radius is 1.0 and the y radius is 2.0, then the y axis is the major axis. Resultantly, a value of norm_distance_on_perimeter=0.0 will correspond to point [x,y] = [0.0, 2.0]. A value of norm_distance_on_perimeter=0.25, which corresponds to a fracπ2 anti-clockwise rotation around the ellipse will correspond to point [x,y] = [-1.0, 0.0]. \n\ne = construct_ellipse(1.0, 2.0)\ngenerate_perimeter_point(0.0, e)\ngenerate_perimeter_point(0.25, e)\n\nIn the event that the ellipse is a circle (the major and minor axis have the same radius), points will be sampled anti-clockwise around the ellipse starting from the most positive point on the x radius (prior to any rotation). \n\nTo demonstrate how sampling works when the ellipse is rotated, for simplicity, consider an ellipse that is a circle with radius 1.0, no translational component and an anti-clockwise rotation of fracπ2. In this case the x axis has been rotated anti-clockwise by 90 degrees and so a value of norm_distance_on_perimeter=0.0 will correspond to point [x,y] = [0.0, 1.0]. A value of norm_distance_on_perimeter=0.25, which corresponds to a fracπ2 anti-clockwise rotation around the rotated ellipse will correspond to point [x,y] = [-1.0, 0.0]. \n\ne = construct_ellipse(1.0, 1.0, pi/2)\ngenerate_perimeter_point(0.0, e)\ngenerate_perimeter_point(0.25, e)\n\nRandom sampling\n\nThis function can be easily used to generate uniform random samples from an ellipse by first sampling N points from a uniform distribution defined on [0,1] and then calling this function for each point 1:N.\n\nFor example using:\n\nusing EllipseSampling\ne = construct_ellipse(2.0,1.0)\nN = 100\nsamples = rand(N)\npoints = generate_perimeter_point.(samples, Ref(e))\n\nNote, here we wrap the ellipse struct e in Ref so that Julia does not try to broadcast over e as well. To get the points generated in this fashion in the same column-wise format as points generated by generate_N_equally_spaced_points we can use:\n\npoints = reduce(hcat, points)\n\nOther distributions defined on [0,1] can be used to generate points on the ellipse's perimeter in a similar fashion.\n\n\n\n\n\ngenerate_perimeter_point(norm_distance_on_perimeter::T, x_radius::T, y_radius::T, α::T=0.0, Cx::T=0.0, Cy::T=0.0) where T<:Float64\n\nAn alternate way to call generate_perimeter_point(norm_distance_on_perimeter::Float64, e::Ellipse), by supplying the parameters of the ellipse to generate a single point on.\n\nArguments\n\nnorm_distance_on_perimeter: a number ∈ [0.0,1.0] which represents the normalised distance on the perimeter of an ellipse. A value of 0.5 corresponds to a point halfway along the ellipse's perimeter, while a value of 0.7 corresponds to a point 70% along the ellipse's perimeter.\nx_radius: radius of the ellipse in the x axis (i.e. when the rotation, α, is zero).\ny_radius: radius of the ellipse in the y axis (i.e. when the rotation, α, is zero).\nα: an angle in radians (0 to 2π) that the ellipse has been rotated by. A positive value represents an anti-clockwise rotation. Default is 0.0.\nCx: the x coordinate of the centre of the ellipse (the translation of the ellipse in the x axis). Default is 0.0.\nCy: the y coordinate of the centre of the ellipse (the translation of the ellipse in the y axis). Default is 0.0.\n\n\n\n\n\ngenerate_perimeter_point(norm_distance_on_perimeter::Float64, Γ::Matrix{Float64}, θmle::Vector{Float64}, ind1::Int, ind2::Int; confidence_level::Float64=0.01)\n\nAn alternate way to call generate_perimeter_point(norm_distance_on_perimeter::Float64, e::Ellipse), by supplying a square matrix Γ, the inverse of the Hessian of a log-likelihood function at its maximum likelihood estimate, indexes of the two variables of interest and the confidence level that represent a 2D ellipse approximation of the log-likelihood function.\n\nArguments\n\nnorm_distance_on_perimeter: a number ∈ [0.0,1.0] which represents the normalised distance on the perimeter of an ellipse. A value of 0.5 corresponds to a point halfway along the ellipse's perimeter, while a value of 0.7 corresponds to a point 70% along the ellipse's perimeter.\nΓ: a square matrix (2D) which is the inverse of the Hessian of a log-likelihood function at its maximum likelihood estimate.\nθmle: the maximum likelihood estimate for the parameters.\nind1: index of the first parameter of interest (corresponds to the row and column index of Γ)\nind2: index of the second parameter of interest (corresponds to the row and column index of Γ).\n\nKeyword Arguments\n\nconfidence_level: the confidence level ∈ [0.0,1.0] at which the ellipse approximation is constructed. Default is 0.01.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/#Ellipse-Angle-Calculation-and-Parameteric-Equations","page":"User Interface","title":"Ellipse Angle Calculation and Parameteric Equations","text":"","category":"section"},{"location":"user_interface/","page":"User Interface","title":"User Interface","text":"t_from_arclength\nt_from_arclength_general\nx_parametric_equation \ny_parametric_equation","category":"page"},{"location":"user_interface/#EllipseSampling.t_from_arclength","page":"User Interface","title":"EllipseSampling.t_from_arclength","text":"t_from_arclength(arc_len::Float64, e::Ellipse)\n\nCalculates the angle t, between 0 and 2π radians, of the location on an unrotated ellipse, given an arc length, arc_len, anticlockwise from the positive major axis along the perimeter of the ellipse. The ellipse's x axis is the major axis. It is recommended to call [t_from_arclength_general(arc_len::T, a::T, b::T) where T<:Float64] rather than this function as it handles the case where the major axis of the ellipse is the y axis.\n\nJulia version of the python function t_from_length by John D. Cook.\n\nArguments\n\narc_len: arc length, between 0.0 and the circumference of the ellipse, anticlockwise from the positive major axis along the perimeter of the ellipse.\ne: a valid EllipseSampling.Ellipse struct which defines an ellipse.\n\n\n\n\n\nt_from_arclength(arc_len::T, a::T, b::T) where T<:Float64\n\nAn alternate way to call t_from_arclength(arc_len::Float64, e::Ellipse).\n\nArguments\n\narc_len: arc length, between 0.0 and the circumference of the ellipse, anticlockwise from the positive major axis along the perimeter of the ellipse.\na: radius of the ellipse's major axis.\nb: radius of the ellipse's minor axis.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/#EllipseSampling.t_from_arclength_general","page":"User Interface","title":"EllipseSampling.t_from_arclength_general","text":"t_from_arclength_general(arc_len::Float64, e::Ellipse)\n\nGeneralised version of t_from_arclength(arc_len::Float64, e::Ellipse) which handles cases where either of the x and y axes are the major axis.\n\nArguments\n\narc_len: arc length, between 0.0 and the circumference of the ellipse, anticlockwise from the positive major axis along the perimeter of the ellipse.\ne: a valid EllipseSampling.Ellipse struct which defines an ellipse.\n\n\n\n\n\nt_from_arclength_general(arc_len::T, a::T, b::T, x_radius::T, y_radius::T) where T<:Float64\n\nGeneralised version of t_from_arclength(arc_len::T, a::T, b::T) where T<:Float64 which handles cases where either of the x and y axes are the major axis.\n\nArguments\n\narc_len: arc length, between 0.0 and the circumference of the ellipse, anticlockwise from the positive major axis along the perimeter of the ellipse.\na: radius of the ellipse's major axis.\nb: radius of the ellipse's minor axis.\nx_radius: radius of the ellipse in the x axis (i.e. when the rotation, α, is zero).\ny_radius: radius of the ellipse in the y axis (i.e. when the rotation, α, is zero).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/#EllipseSampling.x_parametric_equation","page":"User Interface","title":"EllipseSampling.x_parametric_equation","text":"x_parametric_equation(t::T, x_radius::T, y_radius::T, α::T=0.0, Cx::T=0.0) where T<:Float64\n\nImplements the parametric equation for variable x of a translated and rotated ellipse, x(t), where t is an angle between 0 and 2π radians.\n\nArguments\n\nt: an angle between 0 and 2π radians that defines the x location on the ellipse.\nx_radius: radius of the ellipse in the x axis (i.e. when the rotation, α, is zero).\ny_radius: radius of the ellipse in the y axis (i.e. when the rotation, α, is zero).\nα: an angle in radians (0 to 2π) that the ellipse has been rotated by. A positive value represents an anti-clockwise rotation. Default is 0.0.\nCx: the x coordinate of the centre of the ellipse (the translation of the ellipse in the x axis). Default is 0.0.\n\n\n\n\n\nx_parametric_equation(t::T, e::Ellipse) where T<:Float64\n\nImplements the parametric equation for variable x of a translated and rotated ellipse, x(t), where t is an angle between 0 and 2π radians.\n\nArguments\n\nt: an angle between 0 and 2π radians that defines the x location on the ellipse.\ne: a valid Ellipse struct which defines an ellipse.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/#EllipseSampling.y_parametric_equation","page":"User Interface","title":"EllipseSampling.y_parametric_equation","text":"y_parametric_equation(t::T, x_radius::T, y_radius::T, α::T=0.0, Cx::T=0.0) where T<:Float64\n\nImplements the parametric equation for variable y of a translated and rotated ellipse, y(t), where t is an angle between 0 and 2π radians.\n\nArguments\n\nt: an angle between 0 and 2π radians that defines the y location on the ellipse.\nx_radius: radius of the ellipse in the x axis (i.e. when the rotation, α, is zero).\ny_radius: radius of the ellipse in the y axis (i.e. when the rotation, α, is zero).\nα: an angle in radians (0 to 2π) that the ellipse has been rotated by. A positive value represents an anti-clockwise rotation. Default is 0.0.\nCy: the y coordinate of the centre of the ellipse (the translation of the ellipse in the y axis). Default is 0.0.\n\n\n\n\n\ny_parametric_equation(t::T, e::Ellipse) where T<:Float64\n\nImplements the parametric equation for variable y of a translated and rotated ellipse, y(t), where t is an angle between 0 and 2π radians.\n\nArguments\n\nt: an angle between 0 and 2π radians that defines the y location on the ellipse.\ne: a valid Ellipse struct which defines an ellipse.\n\n\n\n\n\n","category":"function"},{"location":"quick_start/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"The following plots require these lines to be run first:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"using EllipseSampling, Plots; gr()\ndefault(palette=:seaborn_colorblind6, msw=0, markeralpha=0.7, \n        aspect_ratio=:equal, label=nothing, dpi=150, size=(450,300))\nPlots.scalefontsizes(0.75)","category":"page"},{"location":"quick_start/#Equally-Spaced-Points","page":"Quick Start","title":"Equally Spaced Points","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"To generate 9 equally spaced points on an ellipse, with x radius of 1.0 and y radius of 0.5, no rotation and a centre of xy = 21 we use:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"e=construct_ellipse(1.0, 0.5, 0.0, 2.0, 1.0)\npoints=generate_N_equally_spaced_points(9, e; start_point_shift=0.0) \nscatter(points[1,:], points[2,:])","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Or alternatively:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"points=generate_N_equally_spaced_points(9, 1.0, 0.5, 0.0, 2.0, 1.0; start_point_shift=0.0) \nscatter(points[1,:], points[2,:])","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"quick_start/#Rotated-Ellipses","page":"Quick Start","title":"Rotated Ellipses","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"If instead our ellipse has an anticlockwise rotation of fracpi3 radians or 60 degrees, we can modify that argument to construct_ellipse.","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"e=construct_ellipse(1.0, 0.5, pi/3.0, 2.0, 1.0)\npoints=generate_N_equally_spaced_points(9, e; start_point_shift=0.0) \nscatter(points[1,:], points[2,:])","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"quick_start/#Clustered-Points","page":"Quick Start","title":"Clustered Points","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"To more easily see the clustering effect we will increase the number of points generated and decrease the y radius. Note, the closer in magnitude the major and minor axis radii are, the weaker the clustering effect.  To generate 30 clustered points on an ellipse, with x radius of 1.0 and y radius of 0.1, no rotation and a centre of xy = 21 we use:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"e=construct_ellipse(1.0, 0.1, 0.0, 2.0, 1.0)\npoints=generate_N_clustered_points(30, e; start_point_shift=0.0, sqrt_distortion=0.0) \nscatter(points[1,:], points[2,:])","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"The clustering effect becomes weaker when we increase the parameter sqrt_distortion towards 1.0:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"plot()\ne=construct_ellipse(1.0, 0.1, 0.0, 2.0, 1.0)\nfor sqrt_distortion in 0.0:0.2:1.0\n    points=generate_N_clustered_points(10, e; start_point_shift=0.0, sqrt_distortion=sqrt_distortion) \n    scatter!(points[1,:], points[2,:], label=string(\"sqrt_distortion=\",sqrt_distortion))\nend","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"The clustering effect is completely gone if our ellipse is a circle:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"plot(palette=:Paired_6)\ne=construct_ellipse(1.0, 1.0, 0.0, 2.0, 1.0)\nfor sqrt_distortion in 0.0:0.5:1.0\n    points=generate_N_clustered_points(10, e; start_point_shift=0.0, sqrt_distortion=sqrt_distortion) \n    scatter!(p, points[1,:], points[2,:], label=string(\"sqrt_distortion=\",sqrt_distortion),\n            markersize=7-sqrt_distortion*4, markeralpha=0.6)\nend","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"quick_start/#Custom-Sampling-Method","page":"Quick Start","title":"Custom Sampling Method","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"If we want to use a custom sampling method that is different to the equal spacing and clustered methods then we can use generate_perimeter_point coupled with any arbitrary distribution defined on [0,1]. For example, if we want to take 100 uniform random samples (uniform with respect to arc length) of our ellipse perimeter we would use:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"e=construct_ellipse(1.0, 0.5, 0.0, 2.0, 1.0)\nN = 100\nsamples = rand(N)\n\n# wrap e in Ref so that the function correctly broadcasts across samples\npoints = generate_perimeter_point.(samples, Ref(e)) \npoints = reduce(hcat, points)\n\nscatter(points[1,:], points[2,:])","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = EllipseSampling","category":"page"},{"location":"#EllipseSampling.jl","page":"Home","title":"EllipseSampling.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"EllipseSampling.jl is a lightweight package for generating points on the boundary defined by an 2D ellipse built around Julia implementations of two functions by John D. Cook. It handles cases where the ellipse has been rotated and/or translated, and where either of the x and y axes is the major or minor axis. It provides methods (generate_N_equally_spaced_points) and (generate_N_clustered_points) to generate N equally-spaced points and clustered points respectively on the ellipse's boundary as well as a method (generate_perimeter_point) to sample singular points uniformly on the boundary. Resultantly, any distribution defined on [0, 1] can be used to sample points. Calculation of the arc length and circumference of an ellipse uses Elliptic.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package's creation was motivated by the need to sample points on the boundary defined by an elliptical approximation of the log-likelihood function around the maximum likelihood estimate of a mechanistic model at a particular confidence level. Resultantly, it also provides a method (EllipseSampling.calculate_ellipse_parameters) to convert the matrix representation of this approximation into the parameters of the equivalent ellipse. Points can then be sampled from this ellipse.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To get started with the package see Quick Start.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A deeper dive into the user interface and internal library can be found in User Interface and Internal Library, respectively.","category":"page"},{"location":"#Getting-Started:-Installation-And-First-Steps","page":"Home","title":"Getting Started: Installation And First Steps","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package, use the following command inside the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"EllipseSampling\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To load the package, use the command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using EllipseSampling","category":"page"}]
}
