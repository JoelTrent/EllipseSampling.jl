<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User Interface · EllipseSampling.jl</title><meta name="title" content="User Interface · EllipseSampling.jl"/><meta property="og:title" content="User Interface · EllipseSampling.jl"/><meta property="twitter:title" content="User Interface · EllipseSampling.jl"/><meta name="description" content="Documentation for EllipseSampling.jl."/><meta property="og:description" content="Documentation for EllipseSampling.jl."/><meta property="twitter:description" content="Documentation for EllipseSampling.jl."/><meta property="og:url" content="https://JoelTrent.github.io/EllipseSampling.jl/user_interface/"/><meta property="twitter:url" content="https://JoelTrent.github.io/EllipseSampling.jl/user_interface/"/><link rel="canonical" href="https://JoelTrent.github.io/EllipseSampling.jl/user_interface/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="EllipseSampling.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">EllipseSampling.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quick_start/">Quick Start</a></li><li class="is-active"><a class="tocitem" href>User Interface</a><ul class="internal"><li><a class="tocitem" href="#Ellipse-Construction"><span>Ellipse Construction</span></a></li><li><a class="tocitem" href="#Sampling-Methods"><span>Sampling Methods</span></a></li><li><a class="tocitem" href="#Ellipse-Angle-Calculation-and-Parameteric-Equations"><span>Ellipse Angle Calculation and Parameteric Equations</span></a></li></ul></li><li><a class="tocitem" href="../internal_library/">Internal Library</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>User Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>User Interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JoelTrent/EllipseSampling.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JoelTrent/EllipseSampling.jl/blob/main/docs/src/user_interface.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#EllipseSampling.construct_ellipse"><code>EllipseSampling.construct_ellipse</code></a></li><li><a href="#EllipseSampling.generate_N_clustered_points"><code>EllipseSampling.generate_N_clustered_points</code></a></li><li><a href="#EllipseSampling.generate_N_equally_spaced_points"><code>EllipseSampling.generate_N_equally_spaced_points</code></a></li><li><a href="#EllipseSampling.generate_perimeter_point"><code>EllipseSampling.generate_perimeter_point</code></a></li><li><a href="#EllipseSampling.t_from_arclength"><code>EllipseSampling.t_from_arclength</code></a></li><li><a href="#EllipseSampling.t_from_arclength_general"><code>EllipseSampling.t_from_arclength_general</code></a></li><li><a href="#EllipseSampling.x_parametric_equation"><code>EllipseSampling.x_parametric_equation</code></a></li><li><a href="#EllipseSampling.y_parametric_equation"><code>EllipseSampling.y_parametric_equation</code></a></li></ul><h1 id="User-Interface"><a class="docs-heading-anchor" href="#User-Interface">User Interface</a><a id="User-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#User-Interface" title="Permalink"></a></h1><h2 id="Ellipse-Construction"><a class="docs-heading-anchor" href="#Ellipse-Construction">Ellipse Construction</a><a id="Ellipse-Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Ellipse-Construction" title="Permalink"></a></h2><p>For ease of use, all ellipse sampling [generation] functions can either be called directly with ellipse parameters such as a, b and α, or we can construct an <a href="../internal_library/#EllipseSampling.Ellipse"><code>EllipseSampling.Ellipse</code></a> struct first with those parameters, and use this struct when calling the generation functions.</p><p>We construct an <a href="../internal_library/#EllipseSampling.Ellipse"><code>EllipseSampling.Ellipse</code></a> struct using <a href="#EllipseSampling.construct_ellipse"><code>construct_ellipse</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EllipseSampling.construct_ellipse" href="#EllipseSampling.construct_ellipse"><code>EllipseSampling.construct_ellipse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">construct_ellipse(x_radius::T, y_radius::T, α::T=0.0, Cx::T=0.0, Cy::T=0.0) where T&lt;:Float64</code></pre><p>Constructs a <a href="../internal_library/#EllipseSampling.Ellipse"><code>EllipseSampling.Ellipse</code></a> <code>struct</code> which contains the information required to define an ellipse which may have been rotated and translated.</p><p><strong>Arguments</strong></p><ul><li><code>x_radius</code>: radius of the ellipse in the x axis (i.e. when the rotation, <code>α</code>, is zero).</li><li><code>y_radius</code>: radius of the ellipse in the y axis (i.e. when the rotation, <code>α</code>, is zero).</li><li><code>α</code>: an angle in radians (0 to 2π) that the ellipse has been rotated by. A positive value represents an anti-clockwise rotation. Default is <code>0.0</code>.</li><li><code>Cx</code>: the x coordinate of the centre of the ellipse (the translation of the ellipse in the x axis). Default is <code>0.0</code>.</li><li><code>Cy</code>: the y coordinate of the centre of the ellipse (the translation of the ellipse in the y axis). Default is <code>0.0</code>.</li></ul><p><strong>Details</strong></p><p>The general equation for a rotated and translated ellipse is given by:</p><p class="math-container">\[1 = A(x-C_x)^2 + B(x-C_x)(y-C_y) + C(y-C_y)^2\]</p><p>Where:</p><p class="math-container">\[A = \bigg(\frac{\cos^2(α)}{a^2} + \frac{\sin^2(α)}{b^2}\bigg)\]</p><p class="math-container">\[B = 2\cos(α)\sin(α)\bigg(\frac{1}{a^2} - \frac{1}{b^2}\bigg)\]</p><p class="math-container">\[C = \bigg(\frac{\sin^2(α)}{a^2} + \frac{\cos^2(α)}{b^2}\bigg)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/EllipseSampling.jl/blob/07473bd6e3a828d3bdc8f09683ab60428fd014f4/src/ellipse_struct.jl#L51-L80">source</a></section></article><h2 id="Sampling-Methods"><a class="docs-heading-anchor" href="#Sampling-Methods">Sampling Methods</a><a id="Sampling-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-Methods" title="Permalink"></a></h2><p>Three sampling methods, <a href="#EllipseSampling.generate_N_equally_spaced_points"><code>generate_N_equally_spaced_points</code></a>, <a href="#EllipseSampling.generate_N_clustered_points"><code>generate_N_clustered_points</code></a> and <a href="#EllipseSampling.generate_perimeter_point"><code>generate_perimeter_point</code></a>, are provided for use.</p><ol><li><a href="#EllipseSampling.generate_N_equally_spaced_points"><code>generate_N_equally_spaced_points</code></a> will generate points uniformly with respect to arc length along the perimeter of an ellipse. </li><li><a href="#EllipseSampling.generate_N_clustered_points"><code>generate_N_clustered_points</code></a> will generate points uniformly with respect to arc length along the perimeter of a distorted version of the input ellipse and then map these onto the input ellipse. The distorted version of the input ellipse varies the major axis radius of the input ellipse between being equal to the minor axis radius and the original major axis radius, allowing a stronger clustering of points around the vertexes of the ellipse on the major axis (i.e. the region of greatest curvature). This means it is a generalised version of <a href="#EllipseSampling.generate_N_equally_spaced_points"><code>generate_N_equally_spaced_points</code></a>. </li><li><a href="#EllipseSampling.generate_perimeter_point"><code>generate_perimeter_point</code></a> will generate a singular point on the ellipse&#39;s perimeter given a specified distance along the normalised perimeter ∈ [0,1]. This is useful for defining a custom sampling method not covered by the previous two sampling methods. </li></ol><p>Example use of these functions and visualisation of their outputs is shown in <a href="../quick_start/#Quick-Start">Quick Start</a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EllipseSampling.generate_N_equally_spaced_points" href="#EllipseSampling.generate_N_equally_spaced_points"><code>EllipseSampling.generate_N_equally_spaced_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_N_equally_spaced_points(num_points::Int, e::Ellipse; start_point_shift::Float64=rand())</code></pre><p>Generates <code>num_points</code> equally spaced points on an ellipse defined by the parameters contained within <code>e</code>. The points are returned as an array with two rows and <code>num_points</code> columns, with each point stored in a column.</p><p><strong>Arguments</strong></p><ul><li><code>num_points</code>: a positive integer number of points to generate that are equally spaced on the ellipse. </li><li><code>e</code>: a valid <a href="../internal_library/#EllipseSampling.Ellipse"><code>EllipseSampling.Ellipse</code></a> struct which defines an ellipse.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>start_point_shift</code>: a number ∈ [0.0,1.0]. Default is <code>rand()</code> (defined on [0.0,1.0]), meaning that, by default, every time this function is called a different set of points will be generated.</li></ul><p><strong>Details</strong></p><p>Points are sampled anti-clockwise around the ellipse starting from the most positive vertex on the major axis prior to any rotation. After a rotation is applied, this vertex may no longer be the most positive vertex on the major axis. Vertex here means the two endpoints that lie on the major axis and intersect the ellipse. If <code>start_point_shift=0.0</code> then the first point on the equally spaced points will be placed on the most positive vertex on the major axis prior to any rotation.</p><p>Equal spacing of points on the ellipse is with respect to arc length. The position of the first point placed on the ellipse can be shifted by <code>start_point_shift</code>, defined on [0.0,1.0], allowing the set of possible points generated for a given <code>num_points</code> to cover the full perimeter. This shift is normalised so that when <code>start_point_shift=1.0</code>, the position of the first point placed on the ellipse is equal to the position of the second point placed on the ellipse when <code>start_point_shift=0.0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/EllipseSampling.jl/blob/07473bd6e3a828d3bdc8f09683ab60428fd014f4/src/generate_points.jl#L215-L232">source</a></section><section><div><pre><code class="language-julia hljs">generate_N_equally_spaced_points(num_points::Int, x_radius::T, y_radius::T, α::T=0.0, Cx::T=0.0, Cy::T=0.0; start_point_shift::Float64=rand()) where T&lt;:Float64</code></pre><p>An alternate way to call <a href="#EllipseSampling.generate_N_equally_spaced_points"><code>generate_N_equally_spaced_points(num_points::Int, e::Ellipse; start_point_shift::Float64=rand())</code></a>, by supplying the parameters of the ellipse to generate points on.</p><p><strong>Arguments</strong></p><ul><li><code>num_points</code>: a positive integer number of points to generate that are equally spaced on the ellipse. </li><li><code>x_radius</code>: radius of the ellipse in the x axis (i.e. when the rotation, <code>α</code>, is zero).</li><li><code>y_radius</code>: radius of the ellipse in the y axis (i.e. when the rotation, <code>α</code>, is zero).</li><li><code>α</code>: an angle in radians (0 to 2π) that the ellipse has been rotated by. A positive value represents an anti-clockwise rotation. Default is <code>0.0</code>.</li><li><code>Cx</code>: the x coordinate of the centre of the ellipse (the translation of the ellipse in the x axis). Default is <code>0.0</code>.</li><li><code>Cy</code>: the y coordinate of the centre of the ellipse (the translation of the ellipse in the y axis). Default is <code>0.0</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>start_point_shift</code>: a number ∈ [0.0,1.0]. Default is <code>rand()</code> (defined on [0.0,1.0]), meaning that, by default, every time this function is called a different set of points will be generated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/EllipseSampling.jl/blob/07473bd6e3a828d3bdc8f09683ab60428fd014f4/src/generate_points.jl#L253-L268">source</a></section><section><div><pre><code class="language-julia hljs">generate_N_equally_spaced_points(num_points::Int, Γ::Matrix{Float64}, θmle::Vector{Float64}, ind1::Int, ind2::Int; confidence_level::Float64=0.01, start_point_shift::Float64=rand())</code></pre><p>An alternate way to call <a href="#EllipseSampling.generate_N_equally_spaced_points"><code>generate_N_equally_spaced_points(num_points::Int, e::Ellipse; start_point_shift::Float64=rand())</code></a>, by supplying a square matrix Γ, the inverse of the Hessian of a log-likelihood function at its maximum likelihood estimate, indexes of the two variables of interest and the confidence level that represent a 2D ellipse approximation of the log-likelihood function.</p><p><strong>Arguments</strong></p><ul><li><code>num_points</code>: a positive integer number of points to generate that are equally spaced on the ellipse. </li><li><code>Γ</code>: a square matrix (2D) which is the inverse of the Hessian of a log-likelihood function at its maximum likelihood estimate.</li><li><code>θmle</code>: the maximum likelihood estimate for the parameters.</li><li><code>ind1</code>: index of the first parameter of interest (corresponds to the row and column index of <code>Γ</code>)</li><li><code>ind2</code>: index of the second parameter of interest (corresponds to the row and column index of <code>Γ</code>).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>confidence_level</code>: the confidence level ∈ [0.0,1.0] at which the ellipse approximation is constructed. Default is <code>0.01</code>.</li><li><code>start_point_shift</code>: a number ∈ [0.0,1.0]. Default is <code>rand()</code> (defined on [0.0,1.0]), meaning that, by default, every time this function is called a different set of points will be generated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/EllipseSampling.jl/blob/07473bd6e3a828d3bdc8f09683ab60428fd014f4/src/generate_points.jl#L276-L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EllipseSampling.generate_N_clustered_points" href="#EllipseSampling.generate_N_clustered_points"><code>EllipseSampling.generate_N_clustered_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_N_clustered_points(num_points::Int, e::Ellipse; start_point_shift::Float64=rand(), sqrt_distortion::Float64=0.0)</code></pre><p>Generates <code>num_points</code> spaced points on an ellipse defined by the parameters contained within <code>e</code>. The points are returned as an array with two rows and <code>num_points</code> columns, with each point stored in a column.</p><p><strong>Arguments</strong></p><ul><li><code>num_points</code>: a positive integer number of points to generate that are spaced on the ellipse. </li><li><code>e</code>: a valid <a href="../internal_library/#EllipseSampling.Ellipse"><code>EllipseSampling.Ellipse</code></a> struct which defines an ellipse.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>start_point_shift</code>: a number ∈ [0.0,1.0]. Default is <code>rand()</code> (defined on [0.0,1.0]), meaning that, by default, every time this function is called a different set of points will be generated.</li><li><code>sqrt_distortion</code>: a number ∈ [0.0,1.0]. Default is <code>0.0</code>, meaning that, by default, this function will evenly space points on the the ellipse <code>e</code> with respect to the parameter <code>t</code>.</li></ul><p><strong>Details</strong></p><p>Points are sampled in the same fashion as in <a href="#EllipseSampling.generate_N_equally_spaced_points"><code>generate_N_equally_spaced_points(num_points::Int, e::Ellipse; start_point_shift::Float64=rand())</code></a>, except that the spacing of them is dependent on the parameter <code>sqrt_distortion</code>. If <code>sqrt_distortion == 1.0</code> then these points are equally spaced with respect to the arc length. If <code>sqrt_distortion == 0.0</code> then these points are equally spaced with respect to the parameter <code>t</code> in the parameteric equations for the x and y locations on an ellipse (<a href="#EllipseSampling.x_parametric_equation"><code>x_parametric_equation(t::T, e::Ellipse) where T&lt;:Float64</code></a> and <a href="#EllipseSampling.y_parametric_equation"><code>y_parametric_equation(t::T, e::Ellipse) where T&lt;:Float64</code></a>). Varying this parameter between <code>0.0</code> and <code>1.0</code> allows all of the spacings between these two extremes to be obtained.</p><p>The impact of using this function is that for all values of <code>sqrt_distortion &lt; 1.0</code>, points generated will be more clustered around the vertexes of the ellipse on the major axis (i.e. the region of greatest curvature). The strength of this clustering increases as <code>sqrt_distortion</code> <span>$\to 0.0$</span>. The strength of the clustering is also dependent on the relative magnitudes of the major and minor axis radii. If the major and minor axis have the same radii, then the ellipse is a circle and no clustering will be observed, irrespective of the value of <code>sqrt_distortion</code>. As the magnitude of the major axis radius increases relative to the minor axis radius, the strength of the clustering will increase. </p><p>This effect is valuable when using an ellipse as a starting point to find a new level set in 2D (that may be an ellipse) that contains the starting ellipse. If we seek to find the new level set by pushing out from the starting ellipse tangentially at each of the generated points then the points that diverge the fastest are located at the region of greatest curvature. If generated points are equally spaced with respect to arc length, then the new level set is likely to be well defined in regions that are approximately parallel to the major axis of the starting ellipse (and with length on a parallel line of similar length to the major axis, particularly for starting ellipses with a significantly larger major axis), but poorly defined in all other regions. The clustering effect is then valuable as it helps to better define the new level set.   </p><p>The function works by defining a new ellipse, <code>e_new</code> with minor axis radius equal to the supplied ellipse&#39;s minor axis radius (<code>e_new.b == e.b</code>) and major axis radius as a function of the supplied ellipse&#39;s, <code>e</code>, major and minor axis radii and the parameter <code>sqrt_distortion</code>. Namely, <code>e_new.a == e.b + sqrt_distortion^2 * (e.a - e.b)</code>. <code>e_new</code> is contained within <code>e</code> and can be varied between a circle and <code>e</code> using the parameter <code>sqrt_distortion</code> ∈ [0.0,1.0]. After defining <code>e_new</code> we determine the angle parameters <code>t_vector</code> that equally spaces <code>num_points</code> on <code>e_new</code> with respect to arc length and then find the points on <code>e</code> parameterised by the elements of <code>t_vector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/EllipseSampling.jl/blob/07473bd6e3a828d3bdc8f09683ab60428fd014f4/src/generate_points.jl#L300-L322">source</a></section><section><div><pre><code class="language-julia hljs">generate_N_clustered_points(num_points::Int, x_radius::T, y_radius::T, α::T=0.0, Cx::T=0.0, Cy::T=0.0; start_point_shift::Float64=rand(), sqrt_distortion::Float64=0.0) where T&lt;:Float64</code></pre><p>An alternate way to call <a href="#EllipseSampling.generate_N_clustered_points"><code>generate_N_clustered_points(num_points::Int, e::Ellipse; start_point_shift::Float64=rand(), sqrt_distortion::Float64=0.)</code></a>, by supplying the parameters of the ellipse to generate points on.</p><p><strong>Arguments</strong></p><ul><li><code>num_points</code>: a positive integer number of points to generate that are equally spaced on the ellipse. </li><li><code>x_radius</code>: radius of the ellipse in the x axis (i.e. when the rotation, <code>α</code>, is zero).</li><li><code>y_radius</code>: radius of the ellipse in the y axis (i.e. when the rotation, <code>α</code>, is zero).</li><li><code>α</code>: an angle in radians (0 to 2π) that the ellipse has been rotated by. A positive value represents an anti-clockwise rotation. Default is <code>0.0</code>.</li><li><code>Cx</code>: the x coordinate of the centre of the ellipse (the translation of the ellipse in the x axis). Default is <code>0.0</code>.</li><li><code>Cy</code>: the y coordinate of the centre of the ellipse (the translation of the ellipse in the y axis). Default is <code>0.0</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>start_point_shift</code>: a number ∈ [0.0,1.0]. Default is <code>rand()</code> (defined on [0.0,1.0]), meaning that, by default, every time this function is called a different set of points will be generated.</li><li><code>sqrt_distortion</code>: a number ∈ [0.0,1.0]. Default is <code>0.0</code>, meaning that, by default, this function will evenly space points on the the ellipse <code>e</code> with respect to the parameter <code>t</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/EllipseSampling.jl/blob/07473bd6e3a828d3bdc8f09683ab60428fd014f4/src/generate_points.jl#L360-L376">source</a></section><section><div><pre><code class="language-julia hljs">generate_N_clustered_points(num_points::Int, Γ::Matrix{Float64}, θmle::Vector{Float64}, ind1::Int, ind2::Int; confidence_level::Float64=0.01, start_point_shift::Float64=rand(), sqrt_distortion::Float64=0.0)</code></pre><p>An alternate way to call <a href="#EllipseSampling.generate_N_clustered_points"><code>generate_N_clustered_points(num_points::Int, e::Ellipse; start_point_shift::Float64=rand(), sqrt_distortion::Float64=0.)</code></a>, by supplying a square matrix Γ, the inverse of the Hessian of a log-likelihood function at its maximum likelihood estimate, indexes of the two variables of interest and the confidence level that represent a 2D ellipse approximation of the log-likelihood function.</p><p><strong>Arguments</strong></p><ul><li><code>num_points</code>: a positive integer number of points to generate that are equally spaced on the ellipse. </li><li><code>Γ</code>: a square matrix (2D) which is the inverse of the Hessian of a log-likelihood function at its maximum likelihood estimate.</li><li><code>θmle</code>: the maximum likelihood estimate for the parameters.</li><li><code>ind1</code>: index of the first parameter of interest (corresponds to the row and column index of <code>Γ</code>)</li><li><code>ind2</code>: index of the second parameter of interest (corresponds to the row and column index of <code>Γ</code>).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>confidence_level</code>: the confidence level ∈ [0.0,1.0] at which the ellipse approximation is constructed. Default is <code>0.01</code>.</li><li><code>start_point_shift</code>: a number ∈ [0.0,1.0]. Default is <code>rand()</code> (defined on [0.0,1.0]), meaning that, by default, every time this function is called a different set of points will be generated.</li><li><code>sqrt_distortion</code>: a number ∈ [0.0,1.0]. Default is <code>0.0</code>, meaning that, by default, this function will evenly space points on the the ellipse <code>e</code> with respect to the parameter <code>t</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/EllipseSampling.jl/blob/07473bd6e3a828d3bdc8f09683ab60428fd014f4/src/generate_points.jl#L384-L400">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EllipseSampling.generate_perimeter_point" href="#EllipseSampling.generate_perimeter_point"><code>EllipseSampling.generate_perimeter_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_perimeter_point(norm_distance_on_perimeter::Float64, e::Ellipse)</code></pre><p>Generates a single point on an ellipse defined by the parameters contained within <code>e</code>, at distance <code>norm_distance_on_perimeter</code> <span>$\times$</span> <code>e.circumference</code> around the circumference. The point is returned as a vector of length two.</p><p><strong>Arguments</strong></p><ul><li><code>norm_distance_on_perimeter</code>: a number ∈ [0.0,1.0] which represents the normalised distance on the perimeter of an ellipse. A value of <code>0.5</code> corresponds to a point halfway along the ellipse&#39;s perimeter, while a value of <code>0.7</code> corresponds to a point 70% along the ellipse&#39;s perimeter.</li><li><code>e</code>: a valid <a href="../internal_library/#EllipseSampling.Ellipse"><code>EllipseSampling.Ellipse</code></a> struct which defines an ellipse.</li></ul><p><strong>Details</strong></p><p>Points are sampled anti-clockwise around the ellipse starting from the most positive vertex on the major axis prior to any rotation. After a rotation is applied, this vertex may no longer be the most positive vertex on the major axis. Vertex here means the two endpoints that lie on the major axis and intersect the ellipse. </p><p>Consider a ellipse that has no translation or rotational component. If the x radius is <code>2.0</code> and the y radius is <code>1.0</code>, then the x axis is the major axis. Resultantly, a value of <code>norm_distance_on_perimeter=0.0</code> will correspond to point <code>[x,y] = [2.0, 0.0]</code>. A value of <code>norm_distance_on_perimeter=0.25</code>, which corresponds to a <span>$\frac{π}{2}$</span> anti-clockwise rotation around the ellipse will correspond to point <code>[x,y] = [0.0, 1.0]</code>. </p><pre><code class="language-julia hljs">using EllipseSampling
e = construct_ellipse(2.0, 1.0)
generate_perimeter_point(0.0, e)
generate_perimeter_point(0.25, e)</code></pre><p>Similarly, if the x radius is <code>1.0</code> and the y radius is <code>2.0</code>, then the y axis is the major axis. Resultantly, a value of <code>norm_distance_on_perimeter=0.0</code> will correspond to point <code>[x,y] = [0.0, 2.0]</code>. A value of <code>norm_distance_on_perimeter=0.25</code>, which corresponds to a <span>$\frac{π}{2}$</span> anti-clockwise rotation around the ellipse will correspond to point <code>[x,y] = [-1.0, 0.0]</code>. </p><pre><code class="language-julia hljs">e = construct_ellipse(1.0, 2.0)
generate_perimeter_point(0.0, e)
generate_perimeter_point(0.25, e)</code></pre><p>In the event that the ellipse is a circle (the major and minor axis have the same radius), points will be sampled anti-clockwise around the ellipse starting from the most positive point on the x radius (prior to any rotation). </p><p>To demonstrate how sampling works when the ellipse is rotated, for simplicity, consider an ellipse that is a circle with radius 1.0, no translational component and an anti-clockwise rotation of <span>$\frac{π}{2}$</span>. In this case the x axis has been rotated anti-clockwise by 90 degrees and so a value of <code>norm_distance_on_perimeter=0.0</code> will correspond to point <code>[x,y] = [0.0, 1.0]</code>. A value of <code>norm_distance_on_perimeter=0.25</code>, which corresponds to a <span>$\frac{π}{2}$</span> anti-clockwise rotation around the rotated ellipse will correspond to point <code>[x,y] = [-1.0, 0.0]</code>. </p><pre><code class="language-julia hljs">e = construct_ellipse(1.0, 1.0, pi/2)
generate_perimeter_point(0.0, e)
generate_perimeter_point(0.25, e)</code></pre><p><strong>Random sampling</strong></p><p>This function can be easily used to generate uniform random samples from an ellipse by first sampling N points from a uniform distribution defined on [0,1] and then calling this function for each point 1:N.</p><p>For example using:</p><pre><code class="language-julia hljs">using EllipseSampling
e = construct_ellipse(2.0,1.0)
N = 100
samples = rand(N)
points = generate_perimeter_point.(samples, Ref(e))</code></pre><p>Note, here we wrap the ellipse struct <code>e</code> in <code>Ref</code> so that Julia does not try to broadcast over <code>e</code> as well. To get the points generated in this fashion in the same column-wise format as points generated by <a href="#EllipseSampling.generate_N_equally_spaced_points"><code>generate_N_equally_spaced_points</code></a> we can use:</p><pre><code class="language-julia hljs">points = reduce(hcat, points)</code></pre><p>Other distributions defined on [0,1] can be used to generate points on the ellipse&#39;s perimeter in a similar fashion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/EllipseSampling.jl/blob/07473bd6e3a828d3bdc8f09683ab60428fd014f4/src/generate_points.jl#L102-L162">source</a></section><section><div><pre><code class="language-julia hljs">generate_perimeter_point(norm_distance_on_perimeter::T, x_radius::T, y_radius::T, α::T=0.0, Cx::T=0.0, Cy::T=0.0) where T&lt;:Float64</code></pre><p>An alternate way to call <a href="#EllipseSampling.generate_perimeter_point"><code>generate_perimeter_point(norm_distance_on_perimeter::Float64, e::Ellipse)</code></a>, by supplying the parameters of the ellipse to generate a single point on.</p><p><strong>Arguments</strong></p><ul><li><code>norm_distance_on_perimeter</code>: a number ∈ [0.0,1.0] which represents the normalised distance on the perimeter of an ellipse. A value of 0.5 corresponds to a point halfway along the ellipse&#39;s perimeter, while a value of 0.7 corresponds to a point 70% along the ellipse&#39;s perimeter.</li><li><code>x_radius</code>: radius of the ellipse in the x axis (i.e. when the rotation, <code>α</code>, is zero).</li><li><code>y_radius</code>: radius of the ellipse in the y axis (i.e. when the rotation, <code>α</code>, is zero).</li><li><code>α</code>: an angle in radians (0 to 2π) that the ellipse has been rotated by. A positive value represents an anti-clockwise rotation. Default is <code>0.0</code>.</li><li><code>Cx</code>: the x coordinate of the centre of the ellipse (the translation of the ellipse in the x axis). Default is <code>0.0</code>.</li><li><code>Cy</code>: the y coordinate of the centre of the ellipse (the translation of the ellipse in the y axis). Default is <code>0.0</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/EllipseSampling.jl/blob/07473bd6e3a828d3bdc8f09683ab60428fd014f4/src/generate_points.jl#L175-L187">source</a></section><section><div><pre><code class="language-julia hljs">generate_perimeter_point(norm_distance_on_perimeter::Float64, Γ::Matrix{Float64}, θmle::Vector{Float64}, ind1::Int, ind2::Int; confidence_level::Float64=0.01)</code></pre><p>An alternate way to call <a href="#EllipseSampling.generate_perimeter_point"><code>generate_perimeter_point(norm_distance_on_perimeter::Float64, e::Ellipse)</code></a>, by supplying a square matrix Γ, the inverse of the Hessian of a log-likelihood function at its maximum likelihood estimate, indexes of the two variables of interest and the confidence level that represent a 2D ellipse approximation of the log-likelihood function.</p><p><strong>Arguments</strong></p><ul><li><code>norm_distance_on_perimeter</code>: a number ∈ [0.0,1.0] which represents the normalised distance on the perimeter of an ellipse. A value of 0.5 corresponds to a point halfway along the ellipse&#39;s perimeter, while a value of 0.7 corresponds to a point 70% along the ellipse&#39;s perimeter.</li><li><code>Γ</code>: a square matrix (2D) which is the inverse of the Hessian of a log-likelihood function at its maximum likelihood estimate.</li><li><code>θmle</code>: the maximum likelihood estimate for the parameters.</li><li><code>ind1</code>: index of the first parameter of interest (corresponds to the row and column index of <code>Γ</code>)</li><li><code>ind2</code>: index of the second parameter of interest (corresponds to the row and column index of <code>Γ</code>).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>confidence_level</code>: the confidence level ∈ [0.0,1.0] at which the ellipse approximation is constructed. Default is <code>0.01</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/EllipseSampling.jl/blob/07473bd6e3a828d3bdc8f09683ab60428fd014f4/src/generate_points.jl#L194-L208">source</a></section></article><h2 id="Ellipse-Angle-Calculation-and-Parameteric-Equations"><a class="docs-heading-anchor" href="#Ellipse-Angle-Calculation-and-Parameteric-Equations">Ellipse Angle Calculation and Parameteric Equations</a><a id="Ellipse-Angle-Calculation-and-Parameteric-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Ellipse-Angle-Calculation-and-Parameteric-Equations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EllipseSampling.t_from_arclength" href="#EllipseSampling.t_from_arclength"><code>EllipseSampling.t_from_arclength</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">t_from_arclength(arc_len::Float64, e::Ellipse)</code></pre><p>Calculates the angle t, between 0 and 2π radians, of the location on an unrotated ellipse, given an arc length, <code>arc_len</code>, anticlockwise from the positive major axis along the perimeter of the ellipse. The ellipse&#39;s x axis is the major axis. It is recommended to call [<code>t_from_arclength_general(arc_len::T, a::T, b::T) where T&lt;:Float64</code>] rather than this function as it handles the case where the major axis of the ellipse is the y axis.</p><p>Julia version of the python function <code>t_from_length</code> by <a href="https://www.johndcook.com/blog/2022/11/02/ellipse-rng/">John D. Cook</a>.</p><p><strong>Arguments</strong></p><ul><li><code>arc_len</code>: arc length, between 0.0 and the circumference of the ellipse, anticlockwise from the positive major axis along the perimeter of the ellipse.</li><li><code>e</code>: a valid <a href="../internal_library/#EllipseSampling.Ellipse"><code>EllipseSampling.Ellipse</code></a> struct which defines an ellipse.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/EllipseSampling.jl/blob/07473bd6e3a828d3bdc8f09683ab60428fd014f4/src/generate_points.jl#L31-L41">source</a></section><section><div><pre><code class="language-julia hljs">t_from_arclength(arc_len::T, a::T, b::T) where T&lt;:Float64</code></pre><p>An alternate way to call <a href="#EllipseSampling.t_from_arclength"><code>t_from_arclength(arc_len::Float64, e::Ellipse)</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>arc_len</code>: arc length, between 0.0 and the circumference of the ellipse, anticlockwise from the positive major axis along the perimeter of the ellipse.</li><li><code>a</code>: radius of the ellipse&#39;s major axis.</li><li><code>b</code>: radius of the ellipse&#39;s minor axis.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/EllipseSampling.jl/blob/07473bd6e3a828d3bdc8f09683ab60428fd014f4/src/generate_points.jl#L47-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EllipseSampling.t_from_arclength_general" href="#EllipseSampling.t_from_arclength_general"><code>EllipseSampling.t_from_arclength_general</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">t_from_arclength_general(arc_len::Float64, e::Ellipse)</code></pre><p>Generalised version of <a href="#EllipseSampling.t_from_arclength"><code>t_from_arclength(arc_len::Float64, e::Ellipse)</code></a> which handles cases where either of the x and y axes are the major axis.</p><p><strong>Arguments</strong></p><ul><li><code>arc_len</code>: arc length, between 0.0 and the circumference of the ellipse, anticlockwise from the positive major axis along the perimeter of the ellipse.</li><li><code>e</code>: a valid <a href="../internal_library/#EllipseSampling.Ellipse"><code>EllipseSampling.Ellipse</code></a> struct which defines an ellipse.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/EllipseSampling.jl/blob/07473bd6e3a828d3bdc8f09683ab60428fd014f4/src/generate_points.jl#L65-L73">source</a></section><section><div><pre><code class="language-julia hljs">t_from_arclength_general(arc_len::T, a::T, b::T, x_radius::T, y_radius::T) where T&lt;:Float64</code></pre><p>Generalised version of <a href="#EllipseSampling.t_from_arclength"><code>t_from_arclength(arc_len::T, a::T, b::T) where T&lt;:Float64</code></a> which handles cases where either of the x and y axes are the major axis.</p><p><strong>Arguments</strong></p><ul><li><code>arc_len</code>: arc length, between 0.0 and the circumference of the ellipse, anticlockwise from the positive major axis along the perimeter of the ellipse.</li><li><code>a</code>: radius of the ellipse&#39;s major axis.</li><li><code>b</code>: radius of the ellipse&#39;s minor axis.</li><li><code>x_radius</code>: radius of the ellipse in the x axis (i.e. when the rotation, <code>α</code>, is zero).</li><li><code>y_radius</code>: radius of the ellipse in the y axis (i.e. when the rotation, <code>α</code>, is zero).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/EllipseSampling.jl/blob/07473bd6e3a828d3bdc8f09683ab60428fd014f4/src/generate_points.jl#L82-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EllipseSampling.x_parametric_equation" href="#EllipseSampling.x_parametric_equation"><code>EllipseSampling.x_parametric_equation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">x_parametric_equation(t::T, x_radius::T, y_radius::T, α::T=0.0, Cx::T=0.0) where T&lt;:Float64</code></pre><p>Implements the parametric equation for variable x of a translated and rotated ellipse, <span>$x(t)$</span>, where t is an angle between 0 and 2π radians.</p><p><strong>Arguments</strong></p><ul><li><code>t</code>: an angle between 0 and 2π radians that defines the x location on the ellipse.</li><li><code>x_radius</code>: radius of the ellipse in the x axis (i.e. when the rotation, <code>α</code>, is zero).</li><li><code>y_radius</code>: radius of the ellipse in the y axis (i.e. when the rotation, <code>α</code>, is zero).</li><li><code>α</code>: an angle in radians (0 to 2π) that the ellipse has been rotated by. A positive value represents an anti-clockwise rotation. Default is <code>0.0</code>.</li><li><code>Cx</code>: the x coordinate of the centre of the ellipse (the translation of the ellipse in the x axis). Default is <code>0.0</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/EllipseSampling.jl/blob/07473bd6e3a828d3bdc8f09683ab60428fd014f4/src/parametric_equations.jl#L1-L12">source</a></section><section><div><pre><code class="language-julia hljs">x_parametric_equation(t::T, e::Ellipse) where T&lt;:Float64</code></pre><p>Implements the parametric equation for variable x of a translated and rotated ellipse, <span>$x(t)$</span>, where t is an angle between 0 and 2π radians.</p><p><strong>Arguments</strong></p><ul><li><code>t</code>: an angle between 0 and 2π radians that defines the x location on the ellipse.</li><li><code>e</code>: a valid <a href="../internal_library/#EllipseSampling.Ellipse"><code>Ellipse</code></a> struct which defines an ellipse.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/EllipseSampling.jl/blob/07473bd6e3a828d3bdc8f09683ab60428fd014f4/src/parametric_equations.jl#L17-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="EllipseSampling.y_parametric_equation" href="#EllipseSampling.y_parametric_equation"><code>EllipseSampling.y_parametric_equation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y_parametric_equation(t::T, x_radius::T, y_radius::T, α::T=0.0, Cx::T=0.0) where T&lt;:Float64</code></pre><p>Implements the parametric equation for variable y of a translated and rotated ellipse, <span>$y(t)$</span>, where <code>t</code> is an angle between 0 and 2π radians.</p><p><strong>Arguments</strong></p><ul><li><code>t</code>: an angle between 0 and 2π radians that defines the y location on the ellipse.</li><li><code>x_radius</code>: radius of the ellipse in the x axis (i.e. when the rotation, <code>α</code>, is zero).</li><li><code>y_radius</code>: radius of the ellipse in the y axis (i.e. when the rotation, <code>α</code>, is zero).</li><li><code>α</code>: an angle in radians (0 to 2π) that the ellipse has been rotated by. A positive value represents an anti-clockwise rotation. Default is <code>0.0</code>.</li><li><code>Cy</code>: the y coordinate of the centre of the ellipse (the translation of the ellipse in the y axis). Default is <code>0.0</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/EllipseSampling.jl/blob/07473bd6e3a828d3bdc8f09683ab60428fd014f4/src/parametric_equations.jl#L30-L41">source</a></section><section><div><pre><code class="language-julia hljs">y_parametric_equation(t::T, e::Ellipse) where T&lt;:Float64</code></pre><p>Implements the parametric equation for variable y of a translated and rotated ellipse, <span>$y(t)$</span>, where <code>t</code> is an angle between 0 and 2π radians.</p><p><strong>Arguments</strong></p><ul><li><code>t</code>: an angle between 0 and 2π radians that defines the y location on the ellipse.</li><li><code>e</code>: a valid <a href="../internal_library/#EllipseSampling.Ellipse"><code>Ellipse</code></a> struct which defines an ellipse.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/EllipseSampling.jl/blob/07473bd6e3a828d3bdc8f09683ab60428fd014f4/src/parametric_equations.jl#L46-L54">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quick_start/">« Quick Start</a><a class="docs-footer-nextpage" href="../internal_library/">Internal Library »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.0.0 on <span class="colophon-date" title="Wednesday 4 October 2023 02:48">Wednesday 4 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
